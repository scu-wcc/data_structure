技巧：
	1.eor&(~eor+1)可以获取eor最右侧位为1，其他位全为0的数。
	2.计算中点(m+n)/2时，m+n可能溢出，假设n>m,写成：m+(n-m)/2就没有溢出风险。m+(n-m)>>1更快。

算法总概：
排序：
外排序：外存中的数据读入内存→在内存中排序→数据写入外存 

冒泡排序，选择排序O(N^2)
插入排序：遍历第一个元素->最后一个元素，每次保证前i个元素有序(1,2,3,4...)，然后将i+1个元素插入到前i个元素中，时间复杂度为O(N^2)

归并排序(mergeSort)O(N*LogN)：通过递归，将一个数组不断拆分成左右两块小的区间直至该区间只剩下两个元素。
					 对左右两个小区间排序完后再对合并的大区间进行排序，直至将整个数组排序。
归并排序效率更高，是因为每次排序的结果都被保存下来了，没有被浪费。
变式：求小和、求逆序对

快速排序(QuickSort):在给定数组中随机寻找一个数，与最后一位交换位置，对其他元素排序，得到小于，等于，大于区域。
				    将最后一位元素与大于区域的第一个元素交换，对大于区域和小于区域进行递归调用。
				    时间复杂度:O(N*LogN),空间复杂度:O(LogN)(最差情况为N)
					
堆:完全二叉树。同级子树从左往右，依次填满
	根据索引i找到父子节点对应关系:{左子树: 2i+1
								   右子树：2i+2
								   父节点：(i-1)/2
								   }
	-大根堆(小根堆):任意子树的最大值(最小值)为当前树的根节点。以下算法以大根堆为例。
	-HeapInsert:向堆中插入元素:插入到末尾，该元素与其父节点比较，交换位置，直到当前节点不大于父节点值，或者当前已为根节点。
	-heapfy删除元素:取出任意i位置的元素，将末尾元素赋值到该位置，并将HeapSize--，
	然后不断与左右子树比较大小，将最大值放在父节点，循环直到当前节点没有子节点或者当前为父节点并且已经是最大值。
	-更改元素:判断变大还是变小，决定向上还是向下比较
注意:系统提供的堆(默认为小根堆)无法做到指定某个index进行操作，只能操作堆的根节点和边界节点，比如弹窗，添加

桶排序：上述排序基于原始数据的大小比较进行排序，有些排序基于数据的其他东西比较，比如数据的位数。
		1.从个位开始到最大数的最高位循环
		2.每次循环时将这个位置的依次从小到大排序，然后加入到桶中，然后按顺序倒出到数组中，此时该位置的顺序已经排号。
		3.依次循环，直到每个位置的顺序都排好了。
	实现:
		1.从个位开始到最大数的最高位循环
		2.每次循环统计<=i的数有几个
		3.按顺序判断当前数字对应的索引的值，将当前数字添加到临时数组[total-1处]，并且当前位置对应的索引的值减1。
		注意：遍历数组应该从右往左遍历。防止出现高位相同，低位较小的先占据高索引位，导致排序错误。
		[51,92,33,35,68] -> [35,33,51,68,92] 错误！
		
排序总结
算法  	 时间复杂度  空间复杂度   稳定性
选择       N^2				1        无
冒泡	   N^2              1        无
插入       N^2              1        有
归并       N*LogN           N        有
快速       N*LogN           LogN     无		实际运行最快的算法，丢失稳定性
堆         N*LogN            1       无		

工程上会选取算法在不同区间的优势综合排序，而不是单一排序；以及考虑数据类型选择有无稳定性的排序
	
查找：
二分查找：每次查找1/2；用法1.查找某个值；2.不小于某值的最左侧的位置；3.查找局部最小(无序数组)









1.时间复杂度

	常数操作：操作时间与数据量无关，总是以固定时间完成。
	
	时间复杂度：算法操作估计最坏时间函数T(n)的最高次项作为时间复杂度O(Tn)
	
	评价算法流程的好坏：优先比较时间复杂度，同阶复杂度时需要根据不同样本量的实际运行时间分析（常数项时间）。
	
	额外空间复杂度：代码执行过程中需要额外申请的存储空间量。
	
	异或：无进位相加，异或运算满足交换律和结合律。对同一块内存地址空间进行异或操作会导致结果出错。



对数器的概念与实现：

	1.想要测试某个方法A，
	2.实现一个复杂度不好，但容易实现的方法B
	3.随机生成样本传给A,B运行，比较结果。
	4.对生成的结果进行判断，改进方法A或B
	5.当多样本测试后结果均正确，则可以确定方法A正确。
	
2.时间复杂度计算

递归函数：
如果递归函数满足每次子递归调用数据量规模相同，就可以用master公式
	T(N) = aT(N/b) + O(N^d)

	b：每次调用子过程的样本量
	a：每次调用子过程的次数
	O(N^d)：子结果合并的时间复杂度
	满足如上公式的程序都可以根据master公式计算时间复杂度：

	log(b，a) > d ：时间复杂度为O(N^log(b，a))
	log(b，a) = d ：时间复杂度为O(N^d * logN)
	log(b，a) < d ：时间复杂度为O(N^d)


3.稳定性:经过该算法排序后相同值的元素的相对位置不发生改变，前后顺序不变。

4.哈希表(HashSet/HashMap类似)

	对于哈希表的增删改操作认为是常数级别，只是这个常数时间很大。

	放入哈希表的数据，如果是基础数据类型/String，内部按照值传递，内存占用就是该数据的大小。
					  如果是引用数据类型，内部按照地址传递，内容占用为内存地址的大小。

5.有序表(TreeSet/TreeMap):存储数据的时候是有序的(引用数据类型需要提供比较器)
	
	各类操作的时间复杂度:O(LogN)
	放入有序表的数据，如果是基础数据类型/String，内部按照值传递，内存占用就是该数据的大小。
					  如果是引用数据类型，内部按照地址传递，内容占用为内存地址的大小。

6.链表

	笔试:使用时间复杂度最低的，不需要考虑空间复杂度
	面试，时间复杂度仍在第一位，空间复杂度也要找到最省的方法 
	
	链表配合栈可以进行很多操作，但是空间复杂度变高。如果使用一些其他的技巧可以降低空间复杂度
	有环/无环的两个节点找出第一个相交节点:
	无环:找出节点长度差，使用双指针同步完成。
	有环:1.获取两个链表的第一个入环节点，
	       使用入环节点判断：快慢指针，让快慢指针第一次相遇，然后其中一个指针指向头，同时每次只走一步，下一次相遇就是第一个入环节点。
		 2.判断入环节点是否为同一个：
		 同一个:入环节点为末尾节点，使用无环链表操作。
		 不同入环节点:其中一个节点绕环走，碰到另一个入环节点就可以返回其中一个当作入环节点。
					  碰不到就说明他们不相交。
	
题目:
	1.回文链表
	2.链表分区
	3.复制链表
	4.有环/无环链表的相交问题
	
7.二叉树
	可以实现递归与非递归的前中后序遍历
	使用非递归遍历时要使用栈辅助遍历
	深度优先遍历：前，中，后序。
	
	广度优先遍历:按层级遍历，从上往下(使用队列实现)
	找到某棵二叉树节点最多的层数。
	
	搜索二叉树:左子节点总是小于根节点，右子节点总是大于根节点。使用中序遍历。
	完全二叉树:树每层都是从左到右依次填满；使用宽度优先遍历，判断某一结点的子树:只有右节点:false; 首次遇到子节点不存在/只有左孩子:之后的节点都应该为叶节点。
	满二叉树:高度和节点关系满足:nodes=2^height - 1; 最后一层一定是满的。
	平衡二叉树：左右子树的高度差不大于1

	非递归实现前中后序遍历
	前(先压入根节点):
		1.弹出当前节点，处理。
		2.压入右节点
		3.压入左节点
		4.循环
	
	后(与前序类似，但是需要多一个辅助栈):
		1.弹出当前节点，压入辅助栈。
		2.压入左节点
		3.压入右节点
		4.循环
	
	中():
		1.压入每颗子树的左树
		2.弹出当前节点，处理
		3.压入右节点
		4.循环

8.图:点集和边集。
图有很多的表达结构，熟悉一套通用的结构并完成相关算法，其他的结构可以通过接口函数转换。

广度优先遍历:使用队列和集合(去重，避免图中有环导致死循环)

深度优先遍历:使用栈和集合
	1.压入第一个节点
	2.取出最上面的节点，处理，然后判断其邻居中是否还有未注册到set的元素，
	  如果有，将当前元素和该邻居压入栈中。循环步骤2。
	3.当所有点都被注册后，依次弹出各个节点，遍历完毕。

拓扑排序：依次找到入度为0的点，擦去其影响，直到无节点。配合队列实现。

最小生成树(无向图)：
	-k算法:将边按照大小从小到大排序，依次取出最小的边，形成环就抛弃，没有形成环就留下。
		1.将每个点视为独立集合。
		2.依次添加最小边的过程中，将边相关的点添加到同一个集合中。
		3.当相关点在集合中存在了，说明该边导致形成环，抛弃。

	-p算法:
		1.获取一个点以及相关边，在其相关边中选择一个值最小的连通下一个点
		2.获取下一个点的相关边，选择值最小且两边点都没有被获取过的
		3.循环上述操作，直至所有点被获取。

DJ最短路径算法:起点到其他点的最短路径
	1.选择开始节点，计算开始节点到其他节点的直接路径值
	2.选择路径值最小的节点作为中间值，计算开始节点到其他节点所需的最短路径值，并更新最短路径值
	3.重复上次操作，直到选择完所有节点














































