技巧：
	1.eor&(~eor+1)可以获取eor最右侧位为1，其他位全为0的数。
	2.计算中点(m+n)/2时，m+n可能溢出，假设n>m,写成：m+(n-m)/2就没有溢出风险。m+(n-m)>>1更快。

算法总概：
排序：
外排序：外存中的数据读入内存→在内存中排序→数据写入外存 

冒泡排序，选择排序O(N^2)
插入排序：遍历第一个元素->最后一个元素，每次保证前i个元素有序(1,2,3,4...)，然后将i+1个元素插入到前i个元素中，时间复杂度为O(N^2)

归并排序(mergeSort)O(N*LogN)：通过递归，将一个数组不断拆分成左右两块小的区间直至该区间只剩下两个元素。
					 对左右两个小区间排序完后再对合并的大区间进行排序，直至将整个数组排序。
归并排序效率更高，是因为每次排序的结果都被保存下来了，没有被浪费。
变式：求小和、求逆序对

快速排序(QuickSort):在给定数组中随机寻找一个数，与最后一位交换位置，对其他元素排序，得到小于，等于，大于区域。
				    将最后一位元素与大于区域的第一个元素交换，对大于区域和小于区域进行递归调用。

	
查找：
二分查找：每次查找1/2；用法1.查找某个值；2.不小于某值的最左侧的位置；3.查找局部最小(无序数组)









1.时间复杂度

	常数操作：操作时间与数据量无关，总是以固定时间完成。
	
	时间复杂度：算法操作估计最坏时间函数T(n)的最高次项作为时间复杂度O(Tn)
	
	评价算法流程的好坏：优先比较时间复杂度，同阶复杂度时需要根据不同样本量的实际运行时间分析（常数项时间）。
	
	额外空间复杂度：代码执行过程中需要额外申请的存储空间量。
	
	异或：无进位相加，异或运算满足交换律和结合律。对同一块内存地址空间进行异或操作会导致结果出错。



对数器的概念与实现：

	1.想要测试某个方法A，
	2.实现一个复杂度不好，但容易实现的方法B
	3.随机生成样本传给A,B运行，比较结果。
	4.对生成的结果进行判断，改进方法A或B
	5.当多样本测试后结果均正确，则可以确定方法A正确。
	
2.时间复杂度计算

递归函数：
如果递归函数满足每次子递归调用数据量规模相同，就可以用master公式
	T(N) = aT(N/b) + O(N^d)

	b：每次调用子过程的样本量
	a：每次调用子过程的次数
	O(N^d)：子结果合并的时间复杂度
	满足如上公式的程序都可以根据master公式计算时间复杂度：

	log(b，a) > d ：时间复杂度为O(N^log(b，a))
	log(b，a) = d ：时间复杂度为O(N^d * logN)
	log(b，a) < d ：时间复杂度为O(N^d)











































































